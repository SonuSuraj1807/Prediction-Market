# EVENTIX — Enterprise-Grade Implementation Plan (Phase 1)

> **Project:** Eventix — Free-to-Play Prediction Market Platform  
> **Classification:** Online Social Game (Online Gaming Act 2025)  
> **Timeline:** 16 weeks (8 sprints × 2 weeks each)  
> **Team:** Solo developer → scalable to enterprise team  
> **Target:** Validate demand, collect skill-predominance data, prepare for Phase 2 (real-money)

---

## 1. Executive Summary

Eventix is a **free-to-play prediction market** where users trade on real-world event outcomes using virtual currency (PRED coins). The platform uses a **Constant Product Market Maker (CPMM)** for price discovery and builds a legal, compliant foundation under India's Online Gaming Act 2025.

This plan transforms the solo-developer roadmap into an **enterprise-grade architecture** — with production-ready patterns for security, scalability, observability, and regulatory compliance — so the codebase is ready for team scaling and Phase 2 (real-money) conversion.

---

## 2. System Architecture

### 2.1 High-Level Architecture

```mermaid
graph TB
    subgraph Client["Client Layer"]
        WEB["Next.js Web App<br/>(SSR + CSR)"]
        PWA["PWA Shell<br/>(Service Worker)"]
    end

    subgraph Edge["Edge / CDN"]
        VCL["Vercel Edge Network<br/>(CDN + Edge Functions)"]
    end

    subgraph API["API Layer"]
        TRPC["tRPC Router<br/>(Type-safe API)"]
        MW["Middleware Stack<br/>(Auth · RateLimit · Validate)"]
    end

    subgraph Services["Service Layer"]
        AUTH_SVC["Auth Service"]
        MARKET_SVC["Market Service"]
        TRADE_SVC["Trading Engine<br/>(CPMM)"]
        LEADERBOARD_SVC["Leaderboard Service"]
        NOTIFICATION_SVC["Notification Service"]
        ANALYTICS_SVC["Analytics Service"]
    end

    subgraph Data["Data Layer"]
        SUPA["Supabase PostgreSQL<br/>(RLS Enabled)"]
        REALTIME["Supabase Realtime<br/>(WebSocket)"]
        CACHE["In-Memory Cache<br/>(LRU)"]
    end

    subgraph Observability["Observability"]
        SENTRY["Sentry<br/>(Error Tracking)"]
        POSTHOG["PostHog<br/>(Product Analytics)"]
        LOGS["Structured Logging<br/>(pino)"]
    end

    WEB --> VCL
    PWA --> VCL
    VCL --> TRPC
    TRPC --> MW
    MW --> AUTH_SVC
    MW --> MARKET_SVC
    MW --> TRADE_SVC
    MW --> LEADERBOARD_SVC
    MW --> NOTIFICATION_SVC
    MW --> ANALYTICS_SVC
    AUTH_SVC --> SUPA
    MARKET_SVC --> SUPA
    TRADE_SVC --> SUPA
    TRADE_SVC --> CACHE
    LEADERBOARD_SVC --> SUPA
    LEADERBOARD_SVC --> CACHE
    NOTIFICATION_SVC --> REALTIME
    ANALYTICS_SVC --> POSTHOG
    TRPC --> SENTRY
    TRPC --> LOGS
```

### 2.2 Data Flow — Trade Lifecycle

```mermaid
sequenceDiagram
    participant U as User
    participant FE as Frontend
    participant API as tRPC API
    participant MW as Middleware
    participant TE as Trading Engine
    participant DB as PostgreSQL
    participant RT as Realtime
    participant LB as Leaderboard

    U->>FE: Click "Buy YES @ 50 PRED"
    FE->>API: trpc.trade.buy({ marketId, side: YES, amount: 50 })
    API->>MW: Auth + RateLimit + Validate
    MW->>TE: Execute Trade
    
    Note over TE: CPMM Calculation
    TE->>TE: k = yes_pool × no_pool
    TE->>TE: shares = pool.no - (k / (pool.yes + amount))
    TE->>TE: newPrice = yes_pool / (yes_pool + no_pool)
    
    TE->>DB: BEGIN TRANSACTION
    DB-->>TE: Lock acquired
    TE->>DB: UPDATE user balance (-50)
    TE->>DB: UPDATE market pool + price
    TE->>DB: UPSERT position
    TE->>DB: INSERT trade (audit)
    TE->>DB: COMMIT
    DB-->>TE: Success
    
    TE->>RT: Broadcast price update
    RT-->>FE: SSE: { marketId, newPrice: 54 }
    TE->>LB: Queue leaderboard recalc
    TE-->>API: { shares: 47, avgPrice: 54 }
    API-->>FE: Trade confirmation
    FE-->>U: Show updated position
```

---

## 3. Project Structure (Monorepo)

```
eventix/
├── .github/
│   ├── workflows/
│   │   ├── ci.yml              # Lint + Type-check + Test on every PR
│   │   ├── deploy-preview.yml  # Vercel preview for PRs
│   │   └── deploy-prod.yml     # Production deploy on main merge
│   └── CODEOWNERS
│
├── src/
│   ├── app/                    # Next.js App Router pages
│   │   ├── (auth)/             # Auth route group
│   │   │   ├── login/page.tsx
│   │   │   └── register/page.tsx
│   │   ├── (main)/             # Authenticated route group
│   │   │   ├── markets/
│   │   │   │   ├── page.tsx            # Market feed
│   │   │   │   └── [id]/page.tsx       # Market detail
│   │   │   ├── portfolio/page.tsx
│   │   │   ├── leaderboard/page.tsx
│   │   │   └── profile/[id]/page.tsx
│   │   ├── admin/              # Admin route group
│   │   │   ├── markets/page.tsx
│   │   │   ├── users/page.tsx
│   │   │   └── resolve/page.tsx
│   │   ├── layout.tsx
│   │   ├── page.tsx            # Landing / hero page
│   │   └── globals.css
│   │
│   ├── components/             # Shared UI components
│   │   ├── ui/                 # Primitives (Button, Card, Modal, etc.)
│   │   ├── market/             # MarketCard, PriceChart, TradeModal
│   │   ├── portfolio/          # PositionRow, PnLChart
│   │   ├── leaderboard/        # LeaderboardTable, UserBadge
│   │   └── layout/             # Navbar, Sidebar, Footer
│   │
│   ├── server/                 # Server-side code
│   │   ├── routers/            # tRPC routers
│   │   │   ├── auth.ts
│   │   │   ├── market.ts
│   │   │   ├── trade.ts
│   │   │   ├── leaderboard.ts
│   │   │   ├── comment.ts
│   │   │   ├── user.ts
│   │   │   └── admin.ts
│   │   ├── services/           # Business logic layer
│   │   │   ├── trading-engine.ts       # CPMM implementation
│   │   │   ├── market-service.ts
│   │   │   ├── leaderboard-service.ts
│   │   │   ├── notification-service.ts
│   │   │   └── analytics-service.ts
│   │   ├── middleware/
│   │   │   ├── auth.ts
│   │   │   ├── rate-limit.ts
│   │   │   └── validation.ts
│   │   ├── trpc.ts             # tRPC init + context
│   │   └── root.ts             # Root tRPC router
│   │
│   ├── lib/                    # Shared utilities
│   │   ├── supabase/
│   │   │   ├── client.ts       # Browser client
│   │   │   ├── server.ts       # Server client (with service role)
│   │   │   └── types.ts        # Auto-generated DB types
│   │   ├── constants.ts
│   │   ├── validators.ts       # Zod schemas
│   │   └── utils.ts
│   │
│   └── hooks/                  # React hooks
│       ├── use-trade.ts
│       ├── use-market.ts
│       ├── use-realtime.ts
│       └── use-auth.ts
│
├── supabase/
│   ├── migrations/             # Versioned SQL migrations
│   │   ├── 001_users.sql
│   │   ├── 002_markets.sql
│   │   ├── 003_positions_trades.sql
│   │   ├── 004_comments.sql
│   │   ├── 005_rls_policies.sql
│   │   ├── 006_functions.sql
│   │   └── 007_materialised_views.sql
│   ├── seed.sql                # Dev seed data
│   └── config.toml
│
├── tests/
│   ├── unit/
│   │   ├── trading-engine.test.ts
│   │   ├── market-service.test.ts
│   │   └── validators.test.ts
│   ├── integration/
│   │   ├── trade-flow.test.ts
│   │   ├── auth-flow.test.ts
│   │   └── market-resolution.test.ts
│   └── e2e/
│       ├── trading.spec.ts     # Playwright
│       ├── onboarding.spec.ts
│       └── leaderboard.spec.ts
│
├── public/
│   ├── manifest.json           # PWA manifest
│   ├── sw.js                   # Service worker
│   ├── icons/                  # PWA icons (192, 512)
│   └── og/                     # Open Graph images
│
├── docs/
│   ├── architecture.md
│   ├── api-reference.md
│   ├── amm-algorithm.md
│   └── legal-compliance.md
│
├── .env.local                  # Local env (gitignored)
├── .env.example                # Template for env vars
├── next.config.ts
├── tailwind.config.ts
├── tsconfig.json
├── vitest.config.ts
├── playwright.config.ts
├── package.json
└── README.md
```

---

## 4. Database Design (Enterprise-Grade)

### 4.1 Schema with Constraints & Indexes

```sql
-- ============================================================
-- 001_users.sql
-- ============================================================
CREATE TABLE users (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone         TEXT UNIQUE,
  email         TEXT UNIQUE,
  display_name  TEXT NOT NULL CHECK (char_length(display_name) BETWEEN 2 AND 30),
  avatar_url    TEXT,
  balance       INTEGER NOT NULL DEFAULT 1000 CHECK (balance >= 0),
  accuracy_score FLOAT DEFAULT 0.0,
  total_trades  INTEGER DEFAULT 0 CHECK (total_trades >= 0),
  total_profit  INTEGER DEFAULT 0,
  rank          INTEGER,
  role          TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin', 'moderator')),
  is_banned     BOOLEAN DEFAULT FALSE,
  last_daily_topup TIMESTAMPTZ,
  referral_code TEXT UNIQUE DEFAULT encode(gen_random_bytes(4), 'hex'),
  referred_by   UUID REFERENCES users(id),
  created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_rank ON users(rank) WHERE rank IS NOT NULL;
CREATE INDEX idx_users_accuracy ON users(accuracy_score DESC);
CREATE INDEX idx_users_referral ON users(referral_code);

-- ============================================================
-- 002_markets.sql
-- ============================================================
CREATE TABLE markets (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title            TEXT NOT NULL CHECK (char_length(title) BETWEEN 10 AND 200),
  description      TEXT,
  category         TEXT NOT NULL CHECK (category IN (
                     'economy', 'sports', 'tech', 'climate', 'policy', 'global', 'entertainment'
                   )),
  region           TEXT NOT NULL DEFAULT 'india' CHECK (region IN (
                     'india', 'usa', 'europe', 'asia', 'global'
                   )),
  flag             TEXT,
  tag              TEXT,
  resolution_source TEXT,
  yes_pool         INTEGER NOT NULL DEFAULT 1000 CHECK (yes_pool > 0),
  no_pool          INTEGER NOT NULL DEFAULT 1000 CHECK (no_pool > 0),
  yes_price        INTEGER NOT NULL DEFAULT 50 CHECK (yes_price BETWEEN 1 AND 99),
  total_volume     INTEGER NOT NULL DEFAULT 0 CHECK (total_volume >= 0),
  trader_count     INTEGER NOT NULL DEFAULT 0 CHECK (trader_count >= 0),
  created_by       UUID NOT NULL REFERENCES users(id),
  resolves_at      TIMESTAMPTZ NOT NULL,
  resolved_at      TIMESTAMPTZ,
  resolution       TEXT CHECK (resolution IN ('YES', 'NO', 'CANCELLED')),
  status           TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'closed', 'resolved')),
  is_featured      BOOLEAN DEFAULT FALSE,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_markets_status ON markets(status);
CREATE INDEX idx_markets_category ON markets(category);
CREATE INDEX idx_markets_resolves_at ON markets(resolves_at) WHERE status = 'open';
CREATE INDEX idx_markets_featured ON markets(is_featured) WHERE is_featured = TRUE;
CREATE INDEX idx_markets_trending ON markets(total_volume DESC, trader_count DESC);

-- ============================================================
-- 003_positions_trades.sql
-- ============================================================
CREATE TABLE positions (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id     UUID NOT NULL REFERENCES users(id),
  market_id   UUID NOT NULL REFERENCES markets(id),
  side        TEXT NOT NULL CHECK (side IN ('YES', 'NO')),
  shares      INTEGER NOT NULL CHECK (shares > 0),
  avg_price   INTEGER NOT NULL CHECK (avg_price BETWEEN 1 AND 99),
  total_cost  INTEGER NOT NULL CHECK (total_cost > 0),
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, market_id, side)
);

CREATE INDEX idx_positions_user ON positions(user_id);
CREATE INDEX idx_positions_market ON positions(market_id);

CREATE TABLE trades (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id     UUID NOT NULL REFERENCES users(id),
  market_id   UUID NOT NULL REFERENCES markets(id),
  side        TEXT NOT NULL CHECK (side IN ('YES', 'NO')),
  action      TEXT NOT NULL DEFAULT 'buy' CHECK (action IN ('buy', 'sell')),
  shares      INTEGER NOT NULL CHECK (shares > 0),
  price       INTEGER NOT NULL CHECK (price BETWEEN 1 AND 99),
  cost        INTEGER NOT NULL,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_trades_user ON trades(user_id);
CREATE INDEX idx_trades_market ON trades(market_id);
CREATE INDEX idx_trades_created ON trades(created_at DESC);

-- ============================================================
-- 004_comments.sql
-- ============================================================
CREATE TABLE comments (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  market_id   UUID NOT NULL REFERENCES markets(id) ON DELETE CASCADE,
  user_id     UUID NOT NULL REFERENCES users(id),
  body        TEXT NOT NULL CHECK (char_length(body) BETWEEN 1 AND 2000),
  is_flagged  BOOLEAN DEFAULT FALSE,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_comments_market ON comments(market_id, created_at DESC);

-- ============================================================
-- 005_rls_policies.sql
-- ============================================================
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE markets ENABLE ROW LEVEL SECURITY;
ALTER TABLE positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE trades ENABLE ROW LEVEL SECURITY;
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;

-- Users: read public, write own
CREATE POLICY "Users are viewable by everyone"
  ON users FOR SELECT USING (true);
CREATE POLICY "Users can update own record"
  ON users FOR UPDATE USING (auth.uid() = id);

-- Markets: read public, create admin only
CREATE POLICY "Markets are viewable by everyone"
  ON markets FOR SELECT USING (true);
CREATE POLICY "Admins can create markets"
  ON markets FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin')
  );

-- Positions: read own, write via service role (trading engine)
CREATE POLICY "Users can view own positions"
  ON positions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Service role manages positions"
  ON positions FOR ALL USING (auth.role() = 'service_role');

-- Trades: read own + market participants
CREATE POLICY "Users can view own trades"
  ON trades FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Service role inserts trades"
  ON trades FOR INSERT WITH CHECK (auth.role() = 'service_role');

-- Comments: read all, write own, delete own/admin
CREATE POLICY "Comments are viewable by everyone"
  ON comments FOR SELECT USING (true);
CREATE POLICY "Authenticated users can comment"
  ON comments FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete own comments"
  ON comments FOR DELETE USING (
    auth.uid() = user_id OR
    EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND role IN ('admin', 'moderator'))
  );

-- ============================================================
-- 006_functions.sql
-- ============================================================

-- Atomic trade execution (prevents race conditions)
CREATE OR REPLACE FUNCTION execute_trade(
  p_user_id UUID,
  p_market_id UUID,
  p_side TEXT,
  p_amount INTEGER
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_market RECORD;
  v_k BIGINT;
  v_new_yes INTEGER;
  v_new_no INTEGER;
  v_shares INTEGER;
  v_new_price INTEGER;
  v_user_balance INTEGER;
BEGIN
  -- Lock market row to prevent concurrent modifications
  SELECT * INTO v_market FROM markets WHERE id = p_market_id FOR UPDATE;

  IF v_market.status != 'open' THEN
    RAISE EXCEPTION 'Market is not open for trading';
  END IF;

  -- Check user balance
  SELECT balance INTO v_user_balance FROM users WHERE id = p_user_id FOR UPDATE;
  IF v_user_balance < p_amount THEN
    RAISE EXCEPTION 'Insufficient balance';
  END IF;

  -- CPMM calculation
  v_k := v_market.yes_pool::BIGINT * v_market.no_pool::BIGINT;

  IF p_side = 'YES' THEN
    v_new_yes := v_market.yes_pool + p_amount;
    v_new_no  := (v_k / v_new_yes)::INTEGER;
    v_shares  := v_market.no_pool - v_new_no;
    v_new_price := ROUND((v_new_yes::FLOAT / (v_new_yes + v_new_no)) * 100)::INTEGER;
  ELSE
    v_new_no  := v_market.no_pool + p_amount;
    v_new_yes := (v_k / v_new_no)::INTEGER;
    v_shares  := v_market.yes_pool - v_new_yes;
    v_new_price := 100 - ROUND((v_new_yes::FLOAT / (v_new_yes + v_new_no)) * 100)::INTEGER;
  END IF;

  -- Apply changes atomically
  UPDATE users SET balance = balance - p_amount, total_trades = total_trades + 1, updated_at = NOW()
    WHERE id = p_user_id;

  UPDATE markets SET
    yes_pool = v_new_yes, no_pool = v_new_no, yes_price = v_new_price,
    total_volume = total_volume + p_amount, trader_count = trader_count + 1,
    updated_at = NOW()
    WHERE id = p_market_id;

  INSERT INTO positions (user_id, market_id, side, shares, avg_price, total_cost)
    VALUES (p_user_id, p_market_id, p_side, v_shares, v_new_price, p_amount)
    ON CONFLICT (user_id, market_id, side) DO UPDATE SET
      shares = positions.shares + EXCLUDED.shares,
      avg_price = ROUND(
        (positions.total_cost + EXCLUDED.total_cost)::FLOAT /
        (positions.shares + EXCLUDED.shares)
      )::INTEGER,
      total_cost = positions.total_cost + EXCLUDED.total_cost,
      updated_at = NOW();

  INSERT INTO trades (user_id, market_id, side, shares, price, cost)
    VALUES (p_user_id, p_market_id, p_side, v_shares, v_new_price, p_amount);

  RETURN jsonb_build_object(
    'shares', v_shares,
    'price', v_new_price,
    'cost', p_amount,
    'new_balance', v_user_balance - p_amount
  );
END;
$$;

-- ============================================================
-- 007_materialised_views.sql
-- ============================================================
CREATE MATERIALIZED VIEW leaderboard AS
  SELECT
    id AS user_id,
    display_name,
    avatar_url,
    accuracy_score,
    total_profit,
    total_trades,
    RANK() OVER (ORDER BY accuracy_score DESC, total_profit DESC) AS rank
  FROM users
  WHERE total_trades >= 5 AND is_banned = FALSE
  ORDER BY rank;

CREATE UNIQUE INDEX idx_leaderboard_user ON leaderboard(user_id);

-- Refresh function (called by cron)
CREATE OR REPLACE FUNCTION refresh_leaderboard()
RETURNS void LANGUAGE plpgsql AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY leaderboard;
  -- Sync ranks back to users table
  UPDATE users u SET rank = lb.rank
    FROM leaderboard lb WHERE u.id = lb.user_id;
END;
$$;
```

### 4.2 Migration Strategy

| Step | Action | Tool |
|------|--------|------|
| 1 | Generate migration files from schema changes | `supabase db diff` |
| 2 | Review generated SQL before applying | Manual review |
| 3 | Apply to local dev database | `supabase db push` |
| 4 | Run integration tests against local DB | `vitest` |
| 5 | Apply to staging (Supabase dashboard or CLI) | `supabase db push --linked` |
| 6 | Smoke test staging | E2E tests |
| 7 | Apply to production | Controlled deploy via CI/CD |

---

## 5. Trading Engine Design (CPMM)

### 5.1 Core Algorithm

The trading engine implements a **Constant Product Market Maker** with these enterprise safeguards:

```typescript
// src/server/services/trading-engine.ts

import { TRPCError } from '@trpc/server';
import { z } from 'zod';

// === Input Validation ===
export const TradeInputSchema = z.object({
  marketId: z.string().uuid(),
  side: z.enum(['YES', 'NO']),
  amount: z.number().int().min(1).max(500),  // Cap per-trade risk
});

// === Pool Type ===
interface Pool { yes: number; no: number; }

// === Trade Result ===
interface TradeResult {
  shares: number;
  newPrice: number;
  pool: Pool;
  slippage: number;
}

// === CPMM Core ===
export function calculateTrade(
  pool: Pool,
  side: 'YES' | 'NO',
  amount: number
): TradeResult {
  const k = pool.yes * pool.no;
  const initialPrice = side === 'YES'
    ? pool.yes / (pool.yes + pool.no)
    : pool.no / (pool.yes + pool.no);

  let newYes: number, newNo: number, shares: number, newPrice: number;

  if (side === 'YES') {
    newYes = pool.yes + amount;
    newNo = k / newYes;
    shares = pool.no - newNo;
    newPrice = Math.round((newYes / (newYes + newNo)) * 100);
  } else {
    newNo = pool.no + amount;
    newYes = k / newNo;
    shares = pool.yes - newYes;
    newPrice = 100 - Math.round((newYes / (newYes + newNo)) * 100);
  }

  // Slippage calculation
  const executionPrice = amount / shares;
  const slippage = Math.abs(executionPrice - initialPrice) / initialPrice;

  // Guard: reject trades with >20% slippage
  if (slippage > 0.20) {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: `Trade would cause ${(slippage * 100).toFixed(1)}% slippage. Max allowed: 20%.`,
    });
  }

  // Guard: price must stay within bounds
  if (newPrice < 1 || newPrice > 99) {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: 'Trade would push price outside 1-99 bounds.',
    });
  }

  return {
    shares: Math.floor(shares),
    newPrice,
    pool: { yes: newYes, no: newNo },
    slippage,
  };
}
```

### 5.2 Safety Rails

| Guard | Rule | Rationale |
|-------|------|-----------|
| Max trade size | 500 PRED per trade | Prevent pool manipulation |
| Slippage limit | ≤ 20% per trade | Protect thin markets |
| Price bounds | 1 ≤ price ≤ 99 | Prevent degenerate states |
| Balance check | Must have sufficient balance | Prevent negative balances |
| Market status | Must be `open` | Prevent trading on resolved markets |
| Rate limiting | 10 trades/minute/user | Prevent abuse |
| Atomic execution | PostgreSQL transaction with `FOR UPDATE` row lock | Prevent race conditions |

---

## 6. Security & Compliance Framework

### 6.1 Authentication & Authorization

```mermaid
graph LR
    subgraph Auth["Authentication Flow"]
        PHONE["Phone OTP<br/>(India Users)"]
        GOOGLE["Google OAuth<br/>(All Users)"]
    end

    PHONE --> SUPA_AUTH["Supabase Auth"]
    GOOGLE --> SUPA_AUTH

    SUPA_AUTH --> JWT["JWT Token<br/>(httpOnly Cookie)"]
    JWT --> MW["Auth Middleware"]
    MW --> RBAC["Role-Based Access"]

    RBAC --> USER_ROLE["User Role<br/>(trade, comment, view)"]
    RBAC --> MOD_ROLE["Moderator Role<br/>(flag, hide, warn)"]
    RBAC --> ADMIN_ROLE["Admin Role<br/>(create markets, resolve, ban)"]
```

### 6.2 Security Checklist

| Area | Measure | Implementation |
|------|---------|----------------|
| **Auth** | JWT via httpOnly cookies | Supabase Auth + middleware |
| **RBAC** | Role-based access control | `user`, `moderator`, `admin` roles |
| **RLS** | Row-Level Security on all tables | Supabase RLS policies (see §4.1) |
| **Input** | Zod validation on every tRPC procedure | Schema validators in `lib/validators.ts` |
| **Rate Limit** | Per-endpoint limits | `rate-limit.ts` middleware (token bucket) |
| **CSRF** | SameSite cookies + Origin checking | Next.js built-in + middleware |
| **XSS** | React auto-escaping + CSP headers | `next.config.ts` security headers |
| **SQL Injection** | Parameterized queries only | Supabase client + stored procedures |
| **Secrets** | Environment variables, never in code | `.env.local` + Vercel encrypted env vars |
| **Audit Trail** | All trades logged immutably | `trades` table (append-only) |

### 6.3 Legal Compliance (Online Gaming Act 2025 + DPDP Act 2023)

| Requirement | Implementation |
|-------------|----------------|
| **No real money** | Balance is virtual PRED coins; no deposit/withdrawal flows |
| **Social game classification** | Terms of Service explicitly classify as "online social game" |
| **Age gate** | 18+ declaration during registration |
| **DPDP consent** | Explicit consent banner + privacy policy link at registration |
| **Data minimization** | Only collect phone/email + display name; no Aadhaar/PAN |
| **Data export** | User can export their data (API endpoint) |
| **Responsible gaming** | Prominent notice on landing + in-app |
| **Skill predominance data** | Brier scores + Sharpe ratios calculated and stored for future NOGC filing |

---

## 7. CI/CD Pipeline

### 7.1 Pipeline Architecture

```mermaid
graph LR
    subgraph PR["Pull Request"]
        LINT["ESLint + Prettier"]
        TYPES["TypeScript<br/>Type Check"]
        UNIT["Vitest<br/>Unit Tests"]
        INTG["Vitest<br/>Integration Tests"]
        PREVIEW["Vercel<br/>Preview Deploy"]
    end

    subgraph Main["Merge to main"]
        E2E["Playwright<br/>E2E Tests"]
        PROD["Vercel<br/>Production Deploy"]
        SENTRY_REL["Sentry<br/>Release + Sourcemaps"]
    end

    LINT --> TYPES --> UNIT --> INTG --> PREVIEW
    PREVIEW --> E2E --> PROD --> SENTRY_REL
```

### 7.2 GitHub Actions Workflows

| Workflow | Trigger | Steps |
|----------|---------|-------|
| `ci.yml` | PR opened/updated | Lint → Type-check → Unit tests → Integration tests |
| `deploy-preview.yml` | PR opened | Vercel preview deployment |
| `deploy-prod.yml` | Merge to `main` | E2E tests → Production deploy → Sentry release |

### 7.3 Environment Strategy

| Environment | Purpose | URL | Database |
|-------------|---------|-----|----------|
| **Local** | Development | `localhost:3000` | Supabase local (Docker) |
| **Preview** | PR review | `*.vercel.app` | Supabase staging project |
| **Production** | Live users | `eventix.in` | Supabase production project |

---

## 8. Observability & Monitoring

### 8.1 Stack

| Tool | Purpose | Integration |
|------|---------|-------------|
| **Sentry** | Error tracking + performance monitoring | `@sentry/nextjs` |
| **PostHog** | Product analytics, funnels, feature flags | `posthog-js` + server-side |
| **pino** | Structured JSON logging | Server-side logger |
| **Supabase Dashboard** | Database metrics, RLS audit | Built-in |
| **Vercel Analytics** | Web Vitals (LCP, FID, CLS) | Built-in |

### 8.2 Key Alerts

| Alert | Threshold | Channel |
|-------|-----------|---------|
| Error rate spike | >5% of requests in 5 min | Sentry → Email |
| Trade failure rate | >2% in 15 min | Sentry → Email |
| Database connection pool exhaustion | >80% utilization | Supabase → Email |
| P95 API latency | >2s sustained | Vercel → Dashboard |

### 8.3 PostHog Event Tracking Plan

| Event | Properties | Purpose |
|-------|------------|---------|
| `user_registered` | `method` (google/phone), `referral_code` | Acquisition funnel |
| `market_viewed` | `market_id`, `category`, `region` | Content engagement |
| `trade_executed` | `market_id`, `side`, `amount`, `shares` | Core action |
| `trade_failed` | `market_id`, `error_type` | Error analysis |
| `position_viewed` | `market_id`, `pnl` | Portfolio engagement |
| `leaderboard_viewed` | `tab` (accuracy/profit/volume) | Feature usage |
| `market_shared` | `market_id`, `platform` | Virality |
| `referral_sent` | `referral_code` | Growth |

---

## 9. Testing Strategy

### 9.1 Test Pyramid

| Layer | Framework | Scope | Target Coverage |
|-------|-----------|-------|-----------------|
| **Unit** | Vitest | CPMM algorithm, validators, utils | ≥ 90% |
| **Integration** | Vitest + Supabase local | Trade flows, auth, market resolution | ≥ 75% |
| **E2E** | Playwright | Critical user journeys | 5-8 scenarios |

### 9.2 Critical Test Scenarios

| # | Test | Type | Priority |
|---|------|------|----------|
| 1 | CPMM buy YES produces correct shares + price | Unit | P0 |
| 2 | CPMM buy NO produces correct shares + price | Unit | P0 |
| 3 | Slippage guard rejects high-impact trades | Unit | P0 |
| 4 | Price bounds guard prevents degenerate prices | Unit | P0 |
| 5 | Concurrent trades don't corrupt pool state | Integration | P0 |
| 6 | User balance goes negative prevention | Integration | P0 |
| 7 | Market resolution settles positions correctly | Integration | P0 |
| 8 | Full trade lifecycle (register → trade → view portfolio) | E2E | P0 |
| 9 | Leaderboard updates after trade | Integration | P1 |
| 10 | Daily PRED top-up works correctly | Integration | P1 |

### 9.3 Test Commands

```bash
# Unit tests
npx vitest run tests/unit

# Integration tests (requires Supabase local running)
npx supabase start
npx vitest run tests/integration

# E2E tests (requires dev server running)
npm run dev &
npx playwright test

# All tests
npm test

# Coverage report
npx vitest run --coverage
```

---

## 10. Performance & Scalability Plan

### 10.1 Frontend Performance

| Technique | Implementation |
|-----------|----------------|
| **SSR for SEO pages** | Market detail, landing page via Next.js `generateMetadata` |
| **Client-side for interactive** | Trade modal, real-time price charts |
| **Image optimization** | `next/image` with Vercel image optimization |
| **Code splitting** | Dynamic imports for heavy components (charts, admin panel) |
| **Lazy loading** | Intersection observer for below-fold content |
| **PWA caching** | Service worker caches static assets + API responses |
| **Bundle analysis** | `@next/bundle-analyzer` in CI |

### 10.2 Backend Performance

| Technique | Implementation |
|-----------|----------------|
| **Connection pooling** | Supabase PgBouncer (built-in) |
| **Materialized views** | Leaderboard refreshed via cron (every 15 min) |
| **Index strategy** | Targeted indexes on hot query paths (see §4.1) |
| **Trade locking** | `FOR UPDATE` row-level locks (not table locks) |
| **LRU cache** | In-memory cache for market list, leaderboard (60s TTL) |
| **Rate limiting** | Token bucket per user per endpoint |

### 10.3 Scalability Thresholds

| MAU | Tier | Estimated Cost | Action Needed |
|-----|------|---------------|---------------|
| 0 – 5,000 | Free tiers | ₹800/month (domain only) | None |
| 5K – 25K | Supabase Pro + Vercel Pro | ₹2,000 – 5,000/month | Upgrade tiers |
| 25K – 100K | Supabase Team + dedicated | ₹15,000 – 30,000/month | Add read replicas, CDN |
| 100K+ | Phase 2 infrastructure | Requires investment | Dedicated infra team |

---

## 11. Sprint Plan (8 Sprints × 2 Weeks)

### Sprint 1 (Weeks 1–2): Foundation & Auth

**Goal:** Runnable app with auth, database, and CI/CD pipeline.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| Project scaffolding | Next.js + Tailwind + tRPC + Supabase | `npm run dev` serves app |
| Auth integration | Google + Phone OTP login | User can log in and see session |
| Database setup | All migration files applied | `supabase db push` succeeds |
| CI/CD pipeline | GitHub Actions + Vercel auto-deploy | PR triggers lint + test + preview |
| Landing page | Hero + waitlist + "Coming Soon" | Deployed at eventix.in |
| Error tracking | Sentry configured | Test error appears in Sentry dashboard |

---

### Sprint 2 (Weeks 3–4): Trading Engine Core

**Goal:** Users can buy YES/NO shares on markets.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| CPMM algorithm | `trading-engine.ts` with safety guards | All unit tests pass (≥10 test cases) |
| Admin market creation | Admin panel to create/edit markets | Admin can create market with all fields |
| Seed markets | 15-20 initial markets | Markets visible on feed |
| Market detail page | Price display + trade history chart | Chart renders with d3/recharts |
| Trade modal | Buy YES/NO with amount picker | Trade executes, balance updates |
| Virtual balance | 1,000 PRED on registration | New user sees 1,000 PRED balance |

---

### Sprint 3 (Weeks 5–6): Market Discovery & UX

**Goal:** Users can discover, filter, and search markets.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| Market feed | Paginated card grid | Loads ≤200ms, pagination works |
| Category filters | Filter by economy, sports, tech, etc. | Filter updates results instantly |
| Region filters | Filter by India, USA, Global, etc. | Filter persists in URL params |
| Search | Full-text search on title + description | Returns relevant results ≤300ms |
| Market cards | Probability bar, volume, trader count | Matches design mockup |
| Trending algorithm | Hot markets by volume + recency | Trending section on homepage |
| PWA manifest | Installable PWA | Chrome shows "Add to Home Screen" |
| Responsive design | Mobile-first responsive | Passes Lighthouse mobile audit |

---

### Sprint 4 (Weeks 7–8): Portfolio & Leaderboard

**Goal:** Users can track performance and compete on leaderboards.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| My Positions | Position list with P&L | Shows all open positions with live P&L |
| Portfolio chart | Value over time | Chart renders with historical data |
| Leaderboard | Global ranking by accuracy, profit | Leaderboard loads ≤500ms |
| User profiles | Public page with trade history | Shareable profile URL works |
| Achievements | Badge system (First Trade, 10-streak, etc.) | Badges awarded automatically |
| Share cards | Shareable prediction cards | Generates Open Graph image |

---

### Sprint 5 (Weeks 9–10): Social & Engagement

**Goal:** Users interact with each other and stay engaged.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| Comments | Thread on each market | User can post and delete own comments |
| Follow traders | Follow/unfollow + following list | Follow state persists correctly |
| Activity feed | Recent trades by followed users | Feed updates in near-real-time |
| Daily top-up | 50 PRED/day free | Top-up granted once per 24h |
| Push notifications | PWA push for resolution + alerts | Notification received on mobile Chrome |
| Referral system | Invite code → 500 PRED bonus each | Both users receive bonus on signup |

---

### Sprint 6 (Weeks 11–12): Resolution & Analytics

**Goal:** Markets can be resolved, payouts settled, skill data collected.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| Market resolution | Admin resolves with source link | Resolution updates market status |
| Auto-settlement | Winning positions receive payout | All position holders paid correctly |
| Brier score | Per-user accuracy scoring | Score calculated after each resolution |
| Skill dashboard | Skill vs. chance analysis charts | Data exportable for legal use |
| Admin dashboard | User management, market ops, flags | Admin can ban user, flag market |
| NOGC data export | Skill predominance data export | CSV/JSON export of aggregate data |

---

### Sprint 7 (Weeks 13–14): Polish & Legal

**Goal:** Production-ready with legal compliance and performance optimization.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| Terms of Service | Legal document reviewed by counsel | Accessible at `/terms` |
| Privacy Policy | DPDP Act 2023 compliant | Accessible at `/privacy` |
| Age gate | 18+ declaration at registration | Cannot register without declaration |
| Responsible gaming | Notice on landing + in-app | Visible on homepage and user profile |
| Performance optimization | Lighthouse ≥90 all categories | Performance, Accessibility, Best Practices, SEO |
| SEO | Meta tags, Open Graph, structured data | Social previews render correctly |
| PWA polish | Offline support, install prompt, splash | Works offline for cached pages |

---

### Sprint 8 (Weeks 15–16): Launch Prep

**Goal:** Beta tested, bug-free, launched to public.

| Task | Deliverable | Acceptance Criteria |
|------|-------------|---------------------|
| Beta test | 20-30 testers recruited | Feedback collected and triaged |
| Bug fixes | All P0/P1 bugs resolved | Zero critical bugs open |
| Market seeding | 30-50 markets across categories | All categories have ≥5 markets |
| Blog content | 3-5 explainer blog posts | Published on blog page or Medium |
| Social media | Twitter/X, Instagram, LinkedIn setup | All profiles live with branding |
| ProductHunt | Launch page prepared | Page ready with screenshots |
| Public launch | Announced on all channels | Live at eventix.in |

---

## 12. Risk Register

| # | Risk | Likelihood | Impact | Mitigation |
|---|------|-----------|--------|------------|
| 1 | Supabase free tier limits hit early | Medium | Medium | Monitor usage; upgrade plan at 3K MAU |
| 2 | CPMM pool manipulation by bots | Low | High | Rate limiting + max trade size + slippage guard |
| 3 | Legal ambiguity around social game status | Low | High | Conservative ToS; lawyer review; no real money |
| 4 | Low user retention after launch | Medium | High | Daily top-ups, referral bonuses, engagement features |
| 5 | Performance degradation at scale | Low | Medium | Materialized views, caching, indexed queries |
| 6 | Data breach / security incident | Low | Critical | RLS, input validation, audit logs, Sentry alerts |

---

## Verification Plan

### Automated Tests

All automated tests will be run using the following commands:

```bash
# 1. Unit tests — CPMM algorithm, validators, utilities
npx vitest run tests/unit --reporter=verbose

# 2. Integration tests — trade flows, auth, market resolution
#    Requires local Supabase instance
npx supabase start
npx vitest run tests/integration --reporter=verbose

# 3. E2E tests — critical user journeys
#    Requires dev server on localhost:3000
npm run dev &
npx playwright test --reporter=list

# 4. Type checking
npx tsc --noEmit

# 5. Linting
npx eslint . --max-warnings=0

# 6. Full CI check (mimics GitHub Actions)
npm run lint && npm run typecheck && npm test
```

### Manual Verification

Since no codebase exists yet, the following manual checks should be performed after each sprint:

1. **Sprint 1:** Open `localhost:3000` → verify landing page loads → click "Login with Google" → verify auth flow completes → check Supabase dashboard for new user row
2. **Sprint 2:** Log in → navigate to a market → execute a trade → verify balance decreases → verify position appears in "My Positions"
3. **Sprint 3:** Use category + region filters → verify market list updates → search for a keyword → verify results are relevant → test on mobile viewport
4. **Sprint 4:** Execute multiple trades → check leaderboard position → visit own profile → share prediction card → verify Open Graph preview
5. **Sprint 5:** Post a comment → follow another user → check activity feed → verify daily top-up → test push notification
6. **Sprint 6:** (Admin) Resolve a market → verify winning positions receive payout → check Brier score updates → export skill data
7. **Sprint 7:** Verify Terms/Privacy pages load → attempt registration without age confirmation → check Lighthouse score ≥ 90 → test PWA offline
8. **Sprint 8:** Full end-to-end walkthrough by 5+ beta testers → zero P0 bugs open → all markets seeded

> [!IMPORTANT]
> Each sprint's manual tests should be documented with screenshots and recorded in the sprint retrospective. Any P0 bugs must be fixed before proceeding to the next sprint.
